import { getHistoricalData, type ValidInterval } from "~/api/fetcherYahoo";
import type { Route } from "../+types/fetchAssetChart";
import { createAsset, getAllAssetBySymbolOrderedDesc } from "~/db/actions";
import type { AssetType } from "~/datatypes/asset";

export async function loader({ request }: Route.LoaderArgs) {
  let url = new URL(request.url);
  let query = url.searchParams.get("q");
  let period1 =
    url.searchParams.get("period1") ||
    new Date(
      new Date().setFullYear(new Date().getFullYear() - 5)
    ).toISOString(); // Default to 5 years ago if period1 is not provided;
  let period2 = url.searchParams.get("period2") || new Date().toISOString(); // Default to now if period2 is not provided
  let interval = url.searchParams.get("interval") || "1d"; // Default to daily interval if not provided

  if (!query) {
    return { error: "No query provided" };
  }

  try {
    console.log(`"Fetching asset chart for query: ${query}
       period1: ${period1} ,
       period2: ${period2},
       interval:${interval}`);
    const assetData = await getAllAssetBySymbolOrderedDesc(query);

    // fetch the most recent asset data from DB
    // If no asset data is found, we will fetch new data from the external API
    // otherwise, data is already sorted by lastUpdated in descending order
    // and we will use that as starting point for fetching new data, but only if the time difference is at least 15 minutes
    // and period1 is not provided in the query params (otherwise, this is a specialized request  )
    let mostRecentAsset =
      assetData && assetData.length > 0 ? assetData[0] : null;
    if (mostRecentAsset) {
      // there is already some chart data in the database. Get the most recent entry
      const lastUpdated = new Date(mostRecentAsset.lastUpdated);
      if (!url.searchParams.get("period1")) {
        // if period1 is not provided, we will use the last updated date to fetch new data since last update
        period1 = lastUpdated.toISOString();
      }
    }
     const period1Date = new Date(period1);
    const period2Date = new Date(period2);
    const timeDifferenceMs = period2Date.getTime() - period1Date.getTime();

    console.log(`Time difference in ms: ${timeDifferenceMs}`);
    let assetMapped: AssetType | undefined;
    try {
      if (period1Date < period2Date && (timeDifferenceMs/60000) >= 15) {
        //only fetch data if the time difference is at least 15 minutes
        const externalChartData = await getHistoricalData(
          query,
          period1,
          period2,
          interval as ValidInterval
        );
        //save the external chart data to the database if needed
        if (!externalChartData) {
          return { error: "No chart data found for the given query" };
        }

        assetMapped = {
          id: 1, // this will be auto-generated by the database
          symbol: externalChartData.meta.symbol,
          currency: externalChartData.meta.currency,
          exchangeName: externalChartData.meta.exchangeName,
          fullExchangeName: mostRecentAsset
            ? mostRecentAsset.fullExchangeName!
            : externalChartData.meta.exchangeName || "",
          instrumentType: externalChartData.meta.instrumentType,
          timezone: externalChartData.meta.timezone,
          exchangeTimezoneName: externalChartData.meta.exchangeTimezoneName,
          longName: mostRecentAsset
            ? mostRecentAsset.longName!
            : externalChartData.meta.symbol || "",
          shortName: mostRecentAsset
            ? mostRecentAsset.shortName!
            : externalChartData.meta.symbol || "",
          quotes: externalChartData.quotes.map((q) => ({
            date: q.date.toString(), // convert to string for consistency.
            high: q.high === null ? undefined : q.high,
            low: q.low === null ? undefined : q.low,
            open: q.open === null ? undefined : q.open,
            close: q.close === null ? undefined : q.close,
            volume: q.volume === null ? undefined : q.volume,
            adjclose: q.adjclose === null ? undefined : q.adjclose,
          })),
          events: {
            // Convert dividends and splits to the expected format. Storing the date as a string for consistency.
            dividends: externalChartData.events?.dividends
              ? externalChartData.events.dividends.map((d) => ({
                  amount: d.amount,
                  date: d.date.toString(), // convert to string for consistency
                }))
              : [],
            splits: externalChartData.events?.splits
              ? externalChartData.events.splits.map((s) => ({
                  date: s.date.toString(), // convert to string for consistency
                  numerator: s.numerator,
                  denominator: s.denominator,
                  splitRatio: s.splitRatio,
                }))
              : [],
          },
          isFromApi: true, // since this data is fetched from an external API
          lastUpdated: new Date().toString(),
        };
        const res = await createAsset(assetMapped);
        if (!res || res[0].id === undefined) {
          return { error: "Failed to save asset data to the database" };
        }
      } else {
        // No need to fetch new data, use the most recent asset data
        console.log(
          `Using existing asset data for ${query} from last updated date: ${mostRecentAsset ? mostRecentAsset.lastUpdated: "N/A"}`
        );
      }
      // combine the new asset with the existing chart data
      // Combine quotes and events from assetMapped and all assets from assetData
      // Merge data from all existing assets
      const combinedQuotes = [...(assetMapped?.quotes || [])];
      const combinedDividends = [...(assetMapped?.events?.dividends || [])];
      const combinedSplits = [...(assetMapped?.events?.splits || [])];

      // Merge data from all existing assets
      assetData.forEach((asset) => {
        if (asset.quotes) {
          combinedQuotes.push(...asset.quotes);
        }

        if (asset.events?.dividends) {
          combinedDividends.push(...asset.events.dividends);
        }

        if (asset.events?.splits) {
          combinedSplits.push(...asset.events.splits);
        }
      });

      // Create the combined asset data
      const combinedAssetData = {
        ...assetMapped,
        quotes: combinedQuotes,
        events: {
          dividends:
            combinedDividends.length > 0 ? combinedDividends : undefined,
          splits: combinedSplits.length > 0 ? combinedSplits : undefined,
        },
      };
      // console.log("Combined Asset Data:", combinedAssetData);
      return combinedAssetData;
    } catch (error) {
      console.error("Error fetching external chart data:", error);
      return { error: "Failed to fetch external chart data" };
    }
  } catch (error) {
    console.error("Error fetching asset chart:", error);
    return { error: "Failed to fetch asset chart" };
  }
}
